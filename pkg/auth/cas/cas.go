package cas

import (
	"fmt"
	"strconv"
	"sync"
	"time"

	"github.com/chinamobile/nlpt/pkg/logs"

	"github.com/google/btree"
	"github.com/parnurzeal/gorequest"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/klog"
)

var (
	casHost string
	casPort int
)

var once sync.Once

var cache *btree.BTree

func SetConnectionInfo(host string, port int) {
	once.Do(func() {
		casHost = host
		casPort = port

		cache = btree.New(32)

		go wait.Until(func() {
			count, err := syncUsers()
			if err != nil {
				klog.Errorf("sync user error: %+v", err)
			} else {
				klog.V(5).Infof("successfully sync %d users", count)
			}
		}, time.Second*10, wait.NeverStop)
	})
}

type AutoGenerated struct {
	Timestamp int64  `json:"timestamp"`
	Status    int    `json:"status"`
	Error     string `json:"error"`
	Exception string `json:"exception"`
	Message   string `json:"message"`
	Path      string `json:"path"`

	Code int    `json:"code"`
	Data User   `json:"data"`
	Desc string `json:"desc"`
}

type User struct {
	UserID      int    `json:"userId"`
	Username    string `json:"username"`
	Password    string `json:"password"`
	Salt        string `json:"salt"`
	Status      int    `json:"status"`
	Email       string `json:"email"`
	Mobile      string `json:"mobile"`
	Description string `json:"description"`
}

func (u User) Less(than btree.Item) bool {
	return u.UserID < than.(User).UserID
}

const path = "cas/user"
const listPath = "cas/user/list"

// TODO for create(update) actions, we should directly get user from cas
func GetUserNameByID(id string) (string, error) {
	iid, err := strconv.ParseInt(id, 10, 0)
	if err != nil {
		return "", fmt.Errorf("expect user id in int format. found %s", id)
	}
	if u := cache.Get(User{
		UserID: int(iid),
	}); u != nil {
		return u.(User).Username, nil
	}
	return GetUserNameByIDFromCas(id)
}

func GetUserNameByIDFromCas(id string) (string, error) {
	request := gorequest.New().SetLogger(logs.GetGoRequestLogger(6)).SetDebug(true).SetCurlCommand(true)
	schema := "http"
	request = request.Get(fmt.Sprintf("%s://%s:%d/%s", schema, casHost, casPort, path)).Query(fmt.Sprintf("userId=%s", id))

	responseBody := &AutoGenerated{}
	response, body, errs := request.EndStruct(responseBody)
	if len(errs) > 0 {
		return "", fmt.Errorf("request for getting cas user error: %+v", errs)
	}
	if response.StatusCode/100 != 2 {
		klog.V(5).Infof("create operation failed: %d %s", response.StatusCode, string(body))
		return "", fmt.Errorf("request for getting cas user error: receive wrong status code: %s", string(body))
	}
	if responseBody.Code != 200 || responseBody.Status == 500 {
		return "", fmt.Errorf("request for getting cas user error: received cod is not 200: desc: %s; error: %s; exception: %s; msg: %s", responseBody.Desc, responseBody.Error, responseBody.Exception, responseBody.Message)
	}
	return responseBody.Data.Username, nil
}

type List struct {
	Timestamp int64  `json:"timestamp"`
	Status    int    `json:"status"`
	Error     string `json:"error"`
	Exception string `json:"exception"`
	Message   string `json:"message"`
	Path      string `json:"path"`

	Code int    `json:"code"`
	Data []User `json:"data"`
	Desc string `json:"desc"`
}

func syncUsers() (int, error) {
	request := gorequest.New().SetLogger(logs.GetGoRequestLogger(6)).SetDebug(true).SetCurlCommand(true)
	schema := "http"
	request = request.Get(fmt.Sprintf("%s://%s:%d/%s", schema, casHost, casPort, listPath)).Query("page=0").Query("limit=999999")

	responseBody := &List{}
	response, body, errs := request.EndStruct(responseBody)
	if len(errs) > 0 {
		return 0, fmt.Errorf("request for getting cas user error: %+v", errs)
	}
	if response.StatusCode/100 != 2 {
		klog.V(5).Infof("create operation failed: %d %s", response.StatusCode, string(body))
		return 0, fmt.Errorf("request for getting cas user error: receive wrong status code: %s", string(body))
	}
	if responseBody.Code != 200 || responseBody.Status == 500 {
		return 0, fmt.Errorf("request for getting cas user error: received cod is not 200: desc: %s; error: %s; exception: %s; msg: %s", responseBody.Desc, responseBody.Error, responseBody.Exception, responseBody.Message)
	}
	for _, u := range responseBody.Data {
		cache.ReplaceOrInsert(u)
	}
	return len(responseBody.Data), nil
}
